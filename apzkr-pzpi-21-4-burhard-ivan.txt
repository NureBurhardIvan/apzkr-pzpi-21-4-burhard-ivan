Міністерство освіти і науки України
Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА 
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для автоматизації роботи готелю.

Студент гр. ПЗПІ-21-4	______________ Бургард І. К.
(підпис)
Керівник роботи	__________________ доц. Лещинська І.О.
(підпис)
	Роботу захищено «__»________2024 р.
з оцінкою ________________________
Комісія:	________________  доц. Лещинський В.О.
(підпис)
_________________ доц. Лещинська І.О.
(підпис)
_________________ ст.викл. Сокорчук І.П.
(підпис)

Харків 
2024 р. 
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук		Кафедра програмної інженерії
Спеціальність 121 – Інженерія програмного забезпечення  
Курс 3 			Семестр 		6					
Навчальна дисципліна Архітектура програмного забезпечення 

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТА
				Бургарду Івану Костянтиновичу			
1. Тема роботи: «Програмна система для автоматизації роботи готелю»
2. Термін узгодження завдання з курсової роботи «31» березня 2024 р. 
3. Термін здачі студентом закінченої роботи «27» серпня 2024 р. 
4. Вихідні дані до проєкту (роботи): В програмній системі передбачити:
унікальність, можливість заробітку, актуальність, розповсюдженість,
масштабованість, пітримка інтернаціоналізації, локалізація, забезпечення
конфіденційності та адміністрування системи, реалізація чотирьох компонентів (Back-end, Front-end, Mobile app, IoT)
5. Зміст пояснювальної записки (перелік питань, що належить розробити)
вступ, аналіз предметної області, постановка задачі, проєктування
програмного проєкту, структура бази даних, розробка програмного проєкту,
опис розробленої програмної системи, висновки, перелік посилань, додатки
6. Перелік графічного матеріалу (діаграми, рисунки, інтерфейси): Deployment Diagram, Use Case Diagram, Entity-Relationship Model, Interaction
Overview Diagram, Activity Diagram, State Diagram, Component Diagram,
Package Diagram. 
КАЛЕНДАРНИЙ ПЛАН
№	Основні етапи виконання проєкту в рамках лабораторних робіт	Термін виконання етапів	Примітка
1	Функціональна специфікація програмного проєкту	17.03.24 – 25.03.24	
2	Проєктування програмного проєкту	25.03.24 – 31.03.24	
3	Кодування програмного проєкту	01.04.24 – 31.05.24	
4	Оформлення пояснювальної записки	01.06.24 – 10.06.24	
5	Захист курсової роботи	27.08.2024	

Дата видачі завдання «25» березня 2024 р.  
Керівник					________________ доц. Лещинська І. О. 
							(підпис)
Завдання прийняв до виконання 
ст.гр. ПЗПІ-21-4 					_____________	Бургард І.К.
(підпис)
 
РЕФЕРАТ


Пояснювальна записка до курсової роботи 46 с., 9 рис., 2 табл., 2 додатки, 5 джерел.
NET, ASP.NET WebAPI, PostgreSQL, ІоТ-пристрій, АВТОМАТИЗАЦІЯ, АДМІНІСТРАТОР, БРОНЮВАННЯ, ГОТЕЛЬ, КІМНАТА, КЛІЄНТ, МОВА ПРОГРАМУВАННЯ, ПРОГРАМНА СИСТЕМА, СЕРВІС.
Об’єктом дослідження є готельна справа, розробка програмної системи для автоматизації роботи готелю, з використанням розумних пристроїв IoT з забезпеченням інтерфейсу для користувачів.
Метою курсової роботи є створення програмної системи, яка дозволятиме автоматизувати процеси бронювання кімнат, замовлення сервісів, контроль середовища в кімнатах.
Загалом, це досягнуто способами взаємодії ІоТ-пристроїв з сервером.
У результаті, розроблено програмну систему для автоматизації роботи готелю. Система включає в себе серверну частину та ІоТ-частину, дозволяє адміністрування системи.


 
ЗМІСТ


Вступ	7
1 Аналіз предметної оласті	8
1.1 Бізнес вимоги	8
1.1.1 Бізнес-можливості	8
1.1.2 Бізнес цілі та критерії успіху	9
1.1.3 Потреби клієнтів або ринку	10
1.1.4 Бізнес-ризики	11
1.2 Концепція рішення	12
1.2.1 Окреслення концепції	12
1.2.2 Головна функціональність	13
1.2.3 Припущення та залежності	13
1.3 Рамки та обмеження	14
1.3.1 Рамки первинного випуску.	14
1.3.2 Рамки наступних випусків	15
1.3.3 Обмеження та винятки.	16
1.4 Бізнес контекст	17
1.4.1 Профілі зацікавлених сторін	17
1.4.2 Пріоритети проєкту	18
1.4.3 Робоче середовище	19
2 Постановка задачі	21
3 Проєктування бази даних	22
3.1 Побудова ER-діаграми	22
3.2 Побудова логічної моделі бази даних.	23
4 Архітектура програмної системи	25
4.1 Архітектура серверної частини	25
4.2 Архітектура ІоТ частини	28
Висновки	31
Перелік джерел посилання	32
Додаток А	33
Програмний код серверної частини	33
А.1 Код Program.cs та конфігуруючих методів	33
А.2 Код сервісу для авторизації та автентифікації через AWS Cognito	37
А.3 Код сервісу для створення бекапу та відновлення бази даних.	40
Додаток Б	44
Програмний код частини ІоТ	44
Б.1 Код класу IoT.cs	44




 
ВСТУП


Готельний бізнес переживає значну трансформацію, зумовлену постійним зростанням очікувань гостей та постійним прагненням до покращення досвіду. Сучасні мандрівники вимагають більше, ніж просто комфортного місця для проживання; вони прагнуть безперешкодної взаємодії, персоналізованих послуг та інтуїтивного контролю над своїм оточенням. Однак традиційні готелі часто намагаються не відставати від цих потреб, часто покладаючись на ручні процеси, обмежений контроль гостей і брак даних у режимі реального часу. Цей розрив між очікуваннями гостей і традиційними готельними практиками створює значні можливості для інновацій.
Багато готельних операцій все ще значною мірою покладаються на ручну роботу, таку як реєстрація гостей, управління запитами на номери та надання послуг гостям. Це може призвести до неефективності, затримок і неоптимального обслуговування гостей.
Гості часто мають обмежений контроль над обстановкою в номері, що призводить до розчарування, коли вони не можуть відрегулювати освітлення, температуру або отримати доступ до розваг на свій розсуд.
Готелі часто не мають доступу до даних в режимі реального часу про вподобання гостей, моделі використання та потреби в послугах. Це обмежує їхню здатність персоналізувати досвід та ефективно оптимізувати роботу.
Як наслідок, зростає потреба в інноваційних рішеннях, які заповнюють цю прогалину. Ці рішення повинні оптимізувати роботу готелів, підвищити рівень задоволеності гостей і забезпечити більш персоналізоване та зручне перебування.

 
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1 Бізнес вимоги
1.1.1 Бізнес-можливості


Ринок не пустий і на ньому присутні конкуренти.
SmartRoom - ця компанія пропонує стандартний набір рішень для контролю над кімнатою. Її плюси - проста інтеграція з існуючими готельними системами, доступна ціна та надійна техніка. Однак, SmartRoom має обмежену функціональність, не дозволяє готелям налаштовувати систему відповідно до своїх специфічних потреб та профілю гостей, і має обмежену інтеграцію з додатками для гостей.
GuestConnect - це платформа, що фокусується на взаємодії з гостями. Її плюси - ефективне спілкування з гостями через мобільний додаток, персоналізовані повідомлення, оновлення, пропозиції та швидка підтримка. GuestConnect також пропонує зручні для користувачів функції, такі як онлайн-бронювання, звернення до консьєржа, додаткові послуги та інтерактивну карту готелю. Однак, GuestConnect не забезпечує комплексного управління кімнатою, часто дорожчий порівняно з іншими рішеннями, і гості мають завантажувати окремий додаток для використання, що може бути незручним для деяких.
SmartHome Plus - ця компанія пропонує рішення, що використовує передові технології "розумного дому". Її плюси - розширена функціональність, що включає контроль над освітленням, температурою, шторами, електронними замками, розумними пристроями, і навіть інтеграцію з особистими пристроями гостей. SmartHome Plus також дозволяє готелям налаштовувати систему відповідно до своїх потреб та пропонувати індивідуальні налаштування для різних типів кімнат. Однак, SmartHome Plus вимагає складної інтеграції з різними пристроями та системами, що може бути дорогим та тривалим процесом. Вона також дорожче порівняно з іншими рішеннями, оскільки використовує передові технології, і має високі технічні вимоги до інфраструктури готелю, що може ускладнити його впровадження в старих готелях. 
VRoom відрізнятиметься тим, що буде пропонувати комплексне рішення, яке об'єднає всі найкращі аспекти існуючих рішень, забезпечивши просту інтеграцію, широку функціональність, доступну ціну, і можливість надання індивідуальних налаштувань та персоналізації. Крім того, VRoom активно використає можливість збору та аналізу даних для покращення обслуговування гостей, зменшення витрат та підвищення ефективності. Серед недоліків можна виділити високу залежність від Інтернету та технологій, велику ціну реалізації та технічну складність.

1.1.2 Бізнес цілі та критерії успіху


BO-1: Підвищити рівень задоволеності гостей на 15%. Ця ціль спрямована на значне підвищення рівня задоволеності гостей шляхом надання більш персоналізованого, зручного та приємного готельного досвіду.
BO-2: Знизити операційні витрати на 10%. Ця ціль фокусується на впорядкуванні операційної діяльності готелю та зниженні витрат за рахунок автоматизації та оптимізації різних процесів.
BO-3: Підвищити залученість гостей та кількість повторних візитів на 10%: Ця ціль спрямована на створення більш цікавого та незабутнього гостьового досвіду, що призведе до збільшення кількості повторних візитів та лояльності.
SC-1: Досягти рівня задоволеності клієнтів щонайменше 90%. Цей критерій успіху підкреслює важливість високої задоволеності клієнтів системою.
SC-2: Впровадити систему в 5 готелях протягом першого року. Цей критерій фокусується на розширенні охоплення системи та демонстрації її цінності для ширшої аудиторії.
SC-3: Досягти позитивної рентабельності інвестицій протягом двох років: Цей критерій підкреслює необхідність того, щоб система була фінансово життєздатною і приносила позитивну рентабельність інвестицій для готелів, які її впроваджують.

1.1.3 Потреби клієнтів або ринку


У нашої системи я бачу два типи користувачів: персонал готелю та гість.
Потреби персоналу готелю:
	оптимізація роботи. Персонал повинен мати можливість легко керувати налаштуваннями номерів та запитами гостей за допомогою зручного інтерфейсу, звільняючи час для інших завдань;
	покращена комунікація. Система повинна забезпечувати безпечний і ефективний канал зв'язку між персоналом і гостями, дозволяючи швидко і точно відповідати на запити і прохання;
	аналітика в режимі реального часу. Система повинна надавати дані та аналітику, щоб допомогти персоналу зрозуміти вподобання та потреби гостей, що дозволить краще планувати та оптимізувати обслуговування;
Потреби гостей:
	легкий і зрозумілий інтерфейс;
	персоналізований досвід. Гості повинні мати можливість налаштовувати параметри своїх номерів і отримувати доступ до персоналізованих послуг і зручностей відповідно до своїх уподобань;
	безпека особистих даних;
	велика якість продукції.




1.1.4 Бізнес-ризики


Конкуренція на ринку:
	Ризик: висока конкуренція може ускладнити проникнення на ринок та привернення користувачів до нашого продукту.
	Рішення: розробка унікальної функціональності та особливостей продукту, які будуть виділяти його серед конкурентів;

Залежність від сторонніх постачальників:
	Ризик: надмірна залежність може призвести до критичного стану компанії у разі перебоїв постачання.
	Рішення: укладення договорів із гарантіями, резерви ресурсів, диверсифікація;
	Технічні проблеми:
	Ризик: технічні проблеми призведуть до дисфункції системи.
	Рішення: регулярне обслуговування елементів системи, резервні копії даних;
Відмова клієнтів:
	Ризик: незадовільність клієнтів продуктом призведе до збитків або навіть банкрутства.
	Рішення: інформаційна підтримка, збір зворотного зв’язку від користувачів, швидке реагування на браковані елементи системи і виправлення.


 
1.2 Концепція рішення
1.2.1 Окреслення концепції


VRoom - це інтегрована система готельної автоматизації, яка поєднує можливості IoT-пристроїв, мобільних додатків та централізованої серверної інфраструктури, щоб забезпечити бездоганний та персоналізований досвід проживання гостей. VRoom спрямована на підвищення задоволеності гостей, надаючи їм більше можливостей контролювати своє середовище та отримувати персоналізовані послуги. Водночас система прагне до підвищення ефективності та зниження операційних витрат готелів шляхом автоматизації процесів та надання аналітичних даних.
VRoom об'єднує різні технології та системи в одну цілісну платформу, що дозволяє уникнути розрізнених рішень та забезпечує плавне взаємодія між різними компонентами системи. VRoom збирає та аналізує дані про переваги та поведінку гостей, щоб надати їм персоналізовані послуги та налаштування кімнати. Система автоматизує багато рутинних операцій, що звільняє час персоналу готелю для надання більш якісного обслуговування гостей. VRoom зменшує витрати готелів шляхом оптимізації споживання енергії, автоматизації процесів та надання аналітичних даних для кращого управління ресурсами. VRoom приділяє особливу увагу безпеці даних та системи, забезпечуючи надійний захист від неправомірного доступу та зловмисних дій.
VRoom прагне до створення такого середовища, де гості можуть відчувати себе комфортно та у безпеці, отримуючи унікальний та персоналізований досвід проживання. Ця система націлена на те, щоб зробити готель не просто місцем для ночівлі, а справжнім центром комфорту та задоволення.



1.2.2 Головна функціональність


MF-1: Регулювання температури в приміщенні.
MF-2: Контроль вологості в приміщенні.
MF-3: Реєстрація та авторизація користувачів.
MF-4: Зберігання історії бронювань.
MF-5: Вибір бронювання та можливість редагування.
MF-6: Надання статистики профілю.
MF-7: Замовлення за типом room-service.
MF-8: Керування доступом до кімнати.


1.2.3 Припущення та залежності


П-1: Готель матиме наявну інфраструктуру, включаючи Wi-Fi та дротове підключення до мережі, для підтримки розгортання системи.
П-2: Готель матиме доступ до технічної підтримки для допомоги у встановленні, налаштуванні та усуненні несправностей.
П-3: Гості будуть готові використовувати систему та її функції для покращення свого перебування.
З-1: Залежність від електромережі та інтернету для доступу до серверу.
З-2: Залежність від стану обладнання.
З-3: Залежність від чинного законодавства України – необхідно дотримуватись регуляторних вимог щодо готелів.

 
1.3 Рамки та обмеження
1.3.1 Рамки первинного випуску.


Серверна частина:
	реєстрація та авторизація користувачів: система повинна забезпечити можливість реєстрації та входу користувачів з різними ролями та правами доступу;
	API для IoT-девайсу: прийом даних і запис до бази даних інформації про вологість, температуру та інші показники;
	функціонал для отримання інформації про профіль користувача, редагування профілю, історія бронювань;
	бронювання: можливість забронювати номер для гостей;
	статистика: отримання інформації про середню зайнятість кімнати, тривалість проживання, пікові періоди, популярності послуг, споживання енергії;
	послуги: можливість замовити собі у номер різноманітні послуги, такі як: прибирання в номер, сніданок/обід/вечеря в номер тощо;
	адміністрування: управління користувачами, магазином обладнання, рецептів, видаткових матеріалів, ролями.
Клієнтська частина:
	веб-інтерфейс для клієнтів: зручна взаємодія з системою через браузер;
	локалізація та інтернаціоналізація: Підтримка різних мов, кодових таблиць, іншої інформації для забезпечення комфортного користування в різних регіонах.
Мобільний додаток:
	можливість реєстрації та авторизації користувачів через мобільний додаток;
	управління IoT та послугами.
IoT-пристрої:
	збір даних про вологість та температуру та відправка їх на сервер через HTTP-запити;
	управління доступом до кімнати.


1.3.2 Рамки наступних випусків


Серверна частина:
	впровадження алгоритмів машинного навчання для створення системи рекомендацій щодо послуг;
	покращення контролю середовища шляхом заміни умовних блоків на алгоритми штучного інтелекту;
	розширення програмного інтерфейсу для IoT-пристроїв: розумні штори, телевізор, холодильник;
	можливість ставити оцінки готелю/кімнаті;
	невеликі оновлення кодової бази для впровадження функціоналу інших частин системи.
Вебсайт:
	відображення рекомендацій для послуг, що буде додано на сервері;
	можливість ставити оцінки готелю/кімнаті;
	додання секції «Новини і анонси» на сайт.
Мобільний застосунок:
	можливість ставити оцінки готелю/кімнаті;
	push-сповіщення.
IoT:
	розширення функціональності: штори, телевізор, холодильник;
	буде додано звукові сигнали.


1.3.3 Обмеження та винятки.


Залежність від доступу до електроенергії:
	обмеження: система потребує стабільного джерела електроенергії для безперебійного функціонування;
	виняток: система має включати в себе акумулятор або генератор для забезпечення роботи в надзвичайних ситуаціях.
Збій Інтернет-з'єднання:
	− обмеження: втрата Інтернет-з'єднання може призвести до неможливості передачі даних на сервер і отримання оновлень;
	− виняток: система повинна мати механізм автономної роботи та можливість зберігання даних локально до відновлення зв'язку.
Обмежені ресурси сервера:
	− обмеження: недостатні обчислювальні ресурси на сервері можуть вплинути на продуктивність системи;
	− виняток: система повинна бути масштабованою, і можливо, буде потрібна додаткова інфраструктура для роботи на великому обсязі.

 
1.4 Бізнес контекст
1.4.1 Профілі зацікавлених сторін


Таблиця 1 – Профілі зацікавлених сторін проєкту

Зацікавлена сторона	Обмеження	Основні інтереси	Ставлення	Основна цінність
Гості	Обмежене технічне знання, надійність системи	Дружній інтерфейс, контроль над станом кімнати	Позитивне, відкрите до нових технологій	Персоналізований досвід, зручність, безпека
Інвестори	Інвестиційний ризик, невизначеність ринку	Грошовий інтерес	Позитивне, очікує гарних прибутків від продажів	Перспективний проєкт, котрий має принести багато прибутків
Працівники готелю	Тренування для роботи з системою	Підвищення ефективності та легкість використання	Позитивне, хоче спростити свою роботу	Спрощена робота, покращена комунікація з гостями


 
1.4.2 Пріоритети проєкту


Таблиця 2 – Пріоритети проєкту

Показники	Виконання (етапи)	Обмеження (граничні значення)	Ступінь свободи (допустимий діапазон)
План робіт	10.06.2024		1-2 місяці від графіку
Функціональність			90% функціональності має бути реалізовано у початковому релізі
Якість			На початковому релізі має пройти всі 100% тестів
Персонал		Максимальний розмір команди: 1 розробник/адміністратор	
Ціна		5000 грн	Допустиме перевищення на 10%


 
1.4.3 Робоче середовище


Програмною системою будуть користуватися з різних країн, тому важливо забезпечити безперебійний доступ. Це буде забезпечено завдяки хмарним сервісам Amazon Web Service. 
Окрім цього важливо додати локалізацію (українська та англійська мови) та інтернаціоналізацію (міри ваги тощо). Потрібно враховувати часові пояси, бо доступ з різних країн. 
У якості бази даних буде використовуватись PostgreSQL – це відкрита і надійна система управління базами даних, що відома своєю стабільністю, масштабованістю та безпекою. Вона дозволяє зберігати великі обсяги даних про користувачів, кімнати та діяльність готелю, забезпечуючи цілісність та доступність даних VRoom. 
Для розробки серверної частини обрано платформу .NET – це потужна платформа розробки, що пропонує широкий набір інструментів та бібліотек для створення надійних та масштабованих серверних додатків. .NET забезпечує підтримку різних мов програмування, включаючи C#, F#, Visual Basic.
Для розробки клієнтської частини проєкту слугуватиме React – це популярна бібліотека JavaScript для створення динамічних та інтерактивних веб-інтерфейсів. React забезпечує компонентний підхід до розробки інтерфейсу, що дозволяє легко створювати складені та масштабовані інтерфейси. React також має велику спільноту розробників та широкий спектр додаткових бібліотек та інструментів.
Для розробки IoT частини продукту буде використано RaspberryPi з C#. У якості середовища розробки виступатиме IDE Rider – це потужна IDE для розробки додатків на .NET. Rider пропонує широкий спектр функцій, що допомагає збільшити продуктивність розробки, наприклад, інтелектуальну підказку коду, налагодження, тестування.
Для розробки мобільного застосунку буде використано Kotlin та Android Studio. Kotlin - це сучасна мова програмування для Android, що забезпечує зручний синтаксис та підтримку функціонального програмування. Kotlin має велику спільноту розробників та підтримується Google. Android Studio - це офіційна IDE для розробки додатків для Android, що забезпечує зручне середовище для розробки, налагодження та тестування мобільних додатків.
 
2 ПОСТАНОВКА ЗАДАЧІ


Після аналізу предметної області, було визначене завдання курсової роботи: створення програмної системи для автоматизації роботи готелю.
База даних буде містити в собі дані про: користувачів, готелі, бронювання, дані з IoT, кімнати, послуги, ролі, резервації послуг.
Для клієнта буде доступний такий функціонал:
	Створення акаунту та можливість увійти в нього.
	Перегляд даних з IoT, інформації профілю, історії бронювань.
	Можливість забронювати номер для себе.
	Можливість замовити послугу у номер.
Для адміністратора буде доступний такий функціонал:
	Перегляд статистики певного готелю або кімнати.
	Керування користувачами.
	Можливість забронювати номер для гостей.
	Замовлення послуг для гостей в номер.
Програмна система має бути такою, що підтримує локалізацію та інтернаціоналізацію.
 
3 ПРОЄКТУВАННЯ БАЗИ ДАНИХ
3.1 Побудова ER-діаграми


Проаналізувавши предметну область, можемо виділити певні зв’язки між сутностями і відобразити це на ER-діаграмі (див. рис. 3.1).


Рисунок 3.1 – ER-діаграма бази даних

Service – це сутність, яка містить інформацію про послуги готелю, які можна замовити в номер. Пов’язана зв’язком «багато-до-багатьох» з сутністю Reservation.
Reservation – містить в собі інформацію про замовлення послуг користувачами. Можна провести аналогію з Booking та Room.
Room – містить в собі інформацію про кімнату готелю. Пов’язана зв’язком «один-до-багатьох» з сутністю Booking та IoTData.
Booking – відповідно, містить в собі інформацію про бронювання кімнати.
User – уособлює в собі користувачів системи, з різними ролями.
Пов’язана зв’язком «один-до-багатьох» з сутністю Reservation та Booking.
IoTData – сутність, яка містить в собі інформацію про дані з IoT-пристрою в кімнатах.


3.2 Побудова логічної моделі бази даних.


Для забезпечення прийнятності бази даних для реляційних СУБД, потрібно позбавитись зв’язку «багато-до-багатьох» між Reservation та Service.
Буде створено проміжну таблицю ReservationService.
Таблиця користувачів буде мати такі атрибути: Id, Username, Role, FirstName, LastName, Email, Phone, Passport.
Таблиця послуг буде мати такі атрибути: Id, Name, Description, Cost.
Таблиця даних з пристрою IoT буде мати такі атрибути:  Id, RoomId, TimeStamp, Temperature, Humidity, OtherMetrics.
Таблиця даних бронювань матиме такі атрибути: Id, UserId, RoomId, CheckInDate, CheckOutDate.
Таблиця кімнати матиме такі атрибути: Id, HotelId, RoomNumber, RoomType, Occupation, Rate.
Таблиця резервації матиме такі атрибути: Id, UserId, RoomId, Date.
Проміжна таблиця матиме такі атрибути: Id, ReservationId, ServiceId.
Усі таблиці відповідають вимогам для третьої форми нормалізації: всі атрибути є атомарними, відсутні дані, що повторюються і всі неключові атрибути в таблицях залежать від свого первинного ключа.
На рисунку 3.2 можна бачити побудовану за цими висновками логічну схему бази даних.

Рисунок 3.2 – Логічна схема бази даних

Всі таблиці відповідають вимогам третьої нормальної форми, тож база загалом знаходиться в третій нормальній формі.
 
4 АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ
4.1 Архітектура серверної частини

Є два типи користувачів системи: гість і адміністратор.
Для гостей буде доступний такий функціонал:
	Створення акаунту та можливість увійти в нього.
	Перегляд даних з IoT, інформації профілю, історії бронювань.
	Можливість забронювати номер для себе.
	Можливість замовити послугу у номер.
Для адміністратора буде доступний такий функціонал:
	Перегляд статистики певного готелю або кімнати.
	Керування користувачами.
	Можливість забронювати номер для гостей.
	Замовлення послуг для гостей в номер.
Взаємодію користувачів з системою можна бачити на діаграмі прецедентів (див. рис. 4.1).


Рисунок 4.1 – Діаграма прецедентів
Для розробки цієї частини системи було обрано технологію ASP.NET Core Web API, що використовує в собі C#. СУБД було обрано реляційну – PostgreSQL у комбінації з Entity Framework, за допомогою якої стає дуже зручно спілкуватись з РСУБД.
На рисунку 4.2 можна побачити діаграму розгортання.


Рисунок 4.2 – Діаграма розгортання

Для зручної взаємодії з API використовується сервіс Swagger. Також для захисту даних під час передачі використовуються сертифікати HTTPS.
Сервер розроблений за Clean Architecture, складається із чотирьох шарів: WebAPI, Application, Infrastructure, Infrastructure.Persistence. Кожен вищий рівень є залежним від попереднього.
Архітектура представлена на діаграмі пакетів (див. рис. 4.3). 


Рисунок 4.3 – Діаграма пакетів

Для зручного перетворення типів об’єктів використовується бібліотека Riok.Mapperly, що зменшує кількість дубльованого коду.
Для реалізації авторизації та автентифікації використано сервіс AWS Cognito разом із JWT токеном.
Частини коду серверної частини наведено в додатку А.



4.2 Архітектура ІоТ частини


ІоТ пристрій має бути присутнім в кімнатах і працювати постійно, відсилаючи дані про свою кімнату на сервер. Об’єктивно, з ІоТ пристроєм може взаємодіяти лише адміністратор. Це відображено на діаграмі прецедентів (див. рис. 4.4).


Рисунок 4.4 – Діаграма прецедентів ІоТ

Одразу після запуску ІоТ пристрій підключиться до серверу і почне відправляти дані про температуру, вологість.
Для розробки ІоТ було використано мову C#, яку можливо запустити, наприклад, на RaspberryPi.
Для перетворення даних в прийнятний для передачі через HTTPS формат було використано бібліотеку Newtonsoft.JSON. Повністю взаємодію відображено на діаграмі пакетів (див. рис. 4.5).


Рисунок 4.5 – Діаграма пакетів ІоТ

Тепер, для того, щоб детальніше відобразити взаємодію користувача з ІоТ пристроєм, було створено діаграму взаємодії (див. рис. 4.6).


Рисунок 4.6 – Діаграма взаємодії ІоТ

Для більш зрозумілого відображення взаємодії ІоТ пристрою з сервером було побудовано діаграму діяльності (див. рис. 4.7).


Рисунок 4.7 – Діаграма діяльності ІоТ

Приклади коду ІоТ частини наведено в додатку Б
 
ВИСНОВКИ


У результаті виконаної роботи була створена програмна система для автоматизації роботи готелю.
Було проведено аналіз предметної області, створено базу даних, створено серверні та ІоТ частини за допомогою платформи .NET, мови C#..
Розроблена програмна система дозволяє користувачам автоматизувати деякі аспекти своєї діяльності, такі як: бронювання номерів, замовлення сервісів, отримання статистики, контроль середовища в кімнатах готелів.
Система автоматично вимірює та відстежує температуру повітря, вологість повітря та подає ці дані в різних міжнародних форматах залежно від локалізації.
Адміністрування системи включає можливості керування користувачами, бронюваннями, сервісами, резервної копії даних.
 
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ

1. Бондарєв В.М. Об'єктно-орієнтоване програмування на С #. Навчальний посібник / В. М. Бондарєв. - Харків: СМІТ, 2009р. - 221 с. (дата звернення: 20.08.2024).
2. Документація ASP.NET Microsoft URL: https://learn.microsoft.com/en-us/dotnet/ (дата звернення: 20.08.2024).
3. Learn Entity Framework Core URL: https://www.learnentityframeworkcore.com/ (дата звернення: 20.08.2024).
4. Mapperly documentation URL : https://mapperly.riok.app/ (дата звернення: 20.08.2024).
5. Clean Architecture Guide URL : https://medium.com/@DrunknCode/clean-architecture-simplified-and-in-depth-guide-026333c54454 (дата звернення: 20.08.2024).
 

ДОДАТОК А
Програмний код серверної частини
А.1 Код Program.cs та конфігуруючих методів


using Infrastructure.Extensions;
using Infrastructure.Persistence.Extensions;
using WebAPI.Extensions;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

builder.Services.RegisterInfrastructureServices(builder.Configuration);
builder.Services.RegisterPersistenceServices(builder.Configuration);
builder.Services.RegisterWebApiServices(builder.Configuration);
var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}
app.UseAuthentication();
app.UseAuthorization();

app.MapControllers();

app.Run();

using Amazon.Extensions.NETCore.Setup;
using Amazon.Runtime;
using Amazon.SecurityToken.Model;
using Application.Common.Interfaces.Services;
using Infrastructure.Services;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Configuration;

namespace Infrastructure.Extensions;

public static class ConfigureServices
{
    public static IServiceCollection RegisterInfrastructureServices(this IServiceCollection services, IConfiguration configuration)
    {
        var awsOptions = new AWSOptions
        {
            Credentials = new BasicAWSCredentials(configuration["AWS:AccessKey"], configuration["AWS:SecretKey"])
        };

        services.AddDefaultAWSOptions(awsOptions);
        services.AddCognitoIdentity();
        services.AddScoped<IAuthService, CognitoAuthService>();
        return services;
    }
} using Application.Common.Interfaces.Repositories;
using Infrastructure.Persistence.Repositories;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Configuration;
using Microsoft.EntityFrameworkCore;

namespace Infrastructure.Persistence.Extensions;

public static class ConfigureServices
{
    public static IServiceCollection RegisterPersistenceServices(this IServiceCollection services, IConfiguration configuration)
    {
        var connectionString = configuration.GetConnectionString("DefaultConnection");
        services.AddDbContext<ApplicationDbContext>(opts => opts.UseNpgsql(connectionString));

        services.AddScoped<IUserRepository, UserRepository>();
        services.AddScoped<IHotelRepository, HotelRepository>();
        services.AddScoped<IServiceRepository, ServiceRepository>();
        services.AddScoped<IRoomRepository, RoomRepository>();

        return services;
    }
}

using Application.Common.Options;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.Extensions.Options;
using Microsoft.IdentityModel.Tokens;
using Microsoft.OpenApi.Models;
using WebApi.OptionsSetup;

namespace WebAPI.Extensions;

public static class ConfigureServices
{
    public static IServiceCollection RegisterWebApiServices(this IServiceCollection services, IConfiguration configuration)
    {
        services.AddControllers();
        services.ConfigureOptions<AwsOptionsSetup>();
        services.AddEndpointsApiExplorer();
        services.AddSwaggerGen(options =>
        {
            options.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
            {
                In = ParameterLocation.Header,
                Description = "Authentication Token",
                Name = "Authorization",
                Type = SecuritySchemeType.Http,
                BearerFormat = "JsonWebToken",
                Scheme = "Bearer"
            });
        });
        var awsOptions = services.BuildServiceProvider().GetService<IOptions<AwsOptions>>()!.Value;
        services.AddAuthentication(options =>
            {
                options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
                options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
            })
            .AddJwtBearer(options =>
            {
                options.Authority = $"https://cognito-idp.{awsOptions.Region}.amazonaws.com/{awsOptions.UserPoolId}";
                options.TokenValidationParameters = new TokenValidationParameters
                {
                    ValidateIssuer = true,
                    ValidIssuer = $"https://cognito-idp.{awsOptions.Region}.amazonaws.com/{awsOptions.UserPoolId}",
                    ValidateLifetime = true,
                    LifetimeValidator = (_, expires, _, _) => expires > DateTime.UtcNow,
                    ValidateAudience = false,
                    RoleClaimType = "custom:role"
                };
            });
        services.AddAuthorization();
        return services;
    }
}


А.2 Код сервісу для авторизації та автентифікації через AWS Cognito


using System;
using System.Collections.Generic;
using Amazon.CognitoIdentityProvider;
using Amazon.CognitoIdentityProvider.Model;
using Amazon.Extensions.CognitoAuthentication;
using Application.Common.Interfaces.Services;
using Application.Common.Options;
using Application.User.DTOs.RequestDTOs;
using Application.User.DTOs.ResponseDTOs;
using Microsoft.Extensions.Options;
using System.Net;
using System.Threading.Tasks;
using Application.Common.Interfaces.Repositories;
using Infrastructure.Persistence;

namespace Infrastructure.Services
{
    public class CognitoAuthService : IAuthService
    {
        private readonly IAmazonCognitoIdentityProvider _identityProvider;
        private readonly IUserRepository _userRepository;
        private readonly CognitoUserPool _userPool;
        private readonly AwsOptions _awsOptions;

        public CognitoAuthService(IAmazonCognitoIdentityProvider identityProvider, CognitoUserPool userPool, IOptions<AwsOptions> awsOptions, IUserRepository userRepository)
        {
            _identityProvider = identityProvider;
            _userPool = userPool;
            _userRepository = userRepository;
            _awsOptions = awsOptions.Value;
        }

        public async Task<bool> ConfirmSignupAsync(SignUpConfirmationDto dto)
        {
            var signUpRequest = new ConfirmSignUpRequest
            {
                ClientId = _awsOptions.ClientId,
                ConfirmationCode = dto.Code,
                Username = dto.UserName
            };

            var response = await _identityProvider.ConfirmSignUpAsync(signUpRequest);

            if (response.HttpStatusCode == HttpStatusCode.OK)
            {
                return true;
            }

            return false;
        }

        public async Task<AdminDeleteUserResponse> DeleteUserAsync(string username)
        {
            var deleteRequest = new AdminDeleteUserRequest
            {
                Username = username,
                UserPoolId = _awsOptions.UserPoolId
            };

            var response = await _identityProvider.AdminDeleteUserAsync(deleteRequest);
            return response;
        }

        public async Task<TokenDto> LoginAsync(AuthCredentialsDto credentials)
        {
            var user = new CognitoUser(credentials.UserName, _awsOptions.ClientId, _userPool, _identityProvider);
            var authRequest = new InitiateSrpAuthRequest
            {
                Password = credentials.Password
            };

            var authResponse = await user.StartWithSrpAuthAsync(authRequest);

            var expiresAt = DateTime.Now + TimeSpan.FromSeconds(authResponse.AuthenticationResult.ExpiresIn);
            var idToken = authResponse.AuthenticationResult.IdToken;
            var refreshToken = authResponse.AuthenticationResult.RefreshToken;

            var response = new TokenDto(idToken, refreshToken, expiresAt);

            return response;
        }

        public async Task<UserGotDto> RegisterAsync(RegisterUserDto registerDto)
        {
            var roleTitle = nameof(Role.User);
            var request = new SignUpRequest
            {
                Username = registerDto.UserName,
                ClientId = _awsOptions.ClientId,
                Password = registerDto.Password,
                UserAttributes = new List<AttributeType>
                    {
                        new()
                        {
                            Name = "email",
                            Value = registerDto.Email
                        },
                        new()
                        {
                            Name = "custom:role",
                            Value = roleTitle
                        }
                    },
            };

            var signUpResponse = await _identityProvider.SignUpAsync(request);

            var a = await _userRepository.Create(registerDto with { Id = new Guid(signUpResponse.UserSub) });
            return a;
        }
    }
}

А.3 Код сервісу для створення бекапу та відновлення бази даних.


using System;
using System.Globalization;
using Application.Common.Interfaces.Services;
using Infrastructure.Persistence;
using Microsoft.EntityFrameworkCore;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using CsvHelper;

namespace Infrastructure.Services;

public class BackupService : IBackupService
{
    private readonly ApplicationDbContext _context;

    public BackupService(ApplicationDbContext context)
    {
        _context = context;
    }

    public async Task SaveToCsv(string directoryPath)
    {
        Directory.CreateDirectory(directoryPath);
        var entityTypes = _context.Model.GetEntityTypes();

        foreach (var entityType in entityTypes)
        {
            var entityName = entityType.ClrType.Name;
            var filePath = Path.Combine(directoryPath, $"{entityName}.csv");
            
            var dbSetProperty = _context.GetType().GetProperty(entityName + "s");
            if (dbSetProperty == null) continue;
            
            var dbSet = dbSetProperty.GetValue(_context);
            var queryable = dbSet as IQueryable<object>;
            if (queryable == null) return;

            var entities = await queryable.ToListAsync();

            using var writer = new StreamWriter(filePath);
            using var csv = new CsvWriter(writer, CultureInfo.InvariantCulture);
            await csv.WriteRecordsAsync(entities);
        }
    }

    public async Task RestoreFromCsv(string directoryPath)
    {
        var entityTypes = _context.Model.GetEntityTypes();

        foreach (var entityType in entityTypes)
        {
            var entityName = entityType.ClrType.Name;
            var filePath = Path.Combine(directoryPath, $"{entityName}.csv");

            if (!File.Exists(filePath)) continue;

            var dbSetProperty = _context.GetType().GetProperty(entityName + "s");
            if (dbSetProperty == null) continue;

            var dbSet = dbSetProperty.GetValue(_context);
            
            using var reader = new StreamReader(filePath);
            using var csv = new CsvReader(reader, CultureInfo.InvariantCulture);
            
            var entityListType = typeof(List<>).MakeGenericType(entityType.ClrType);
            var entities = (IList)Activator.CreateInstance(entityListType);

            var records = csv.GetRecords(entityType.ClrType);
            foreach (var record in records)
            {
                entities.Add(record);
            }
            
            var addRangeMethod = dbSet.GetType().GetMethod("AddRange", new[] { typeof(IEnumerable<>).MakeGenericType(entityType.ClrType) });
            if (addRangeMethod != null)
            {
                addRangeMethod.Invoke(dbSet, new object[] { entities });
            }
            
            await _context.SaveChangesAsync();
        }
    }
}

 
ДОДАТОК Б
Програмний код частини ІоТ
Б.1 Код класу IoT.cs


using System.Text;

namespace VRoom_IoT;

public class Iot
{
    private const string RoomId = "b7392d4e-11c6-49d3-b8e0-0a88b40375e5";
    private const string BaseUrl = "http://localhost:5120/api";
    private string _localization = "en";

    public async Task<string> SendIoTData()
    {
        using var httpClient = new HttpClient();

        Random random = new Random();

        int randomNumber = random.Next(-30, 151);
        
        var requestBody = new SendIoTDataRequestDto
        {
            RoomId = new Guid(RoomId),
            TemperatureC = randomNumber,
            TemperatureF = 0,
            Humidity = 60.5,
            TimeStamp = DateTime.UtcNow,
            OtherMetrics = ""
        };
        if(_localization == "us")
        {
            requestBody = new SendIoTDataRequestDto
            {
                RoomId = new Guid(RoomId),
                TemperatureC = 0,
                TemperatureF = randomNumber*9/5+32,
                Humidity = 60.5,
                TimeStamp = DateTime.UtcNow,
                OtherMetrics = ""
            };
        }
        

        
        var jsonPayload = Newtonsoft.Json.JsonConvert.SerializeObject(requestBody);

       
        var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

        try
        {
            Console.WriteLine($"Sending room data to server... " +
                              $"\n\tTemperature: {(_localization == "us" ? requestBody.TemperatureF : requestBody.TemperatureC)}" +
                              $"\n\tHumidity: {requestBody.Humidity}" +
                              $"\n\tTimeStamp: {requestBody.TimeStamp}" +
                              $"\n");
       
            var response = await httpClient.PostAsync($"{BaseUrl}/IoT/SendData", content);
            
            if (response.IsSuccessStatusCode)
            {
                var responseContent = await response.Content.ReadAsStringAsync();

                return responseContent;
            }
            else
            {
                Console.WriteLine($"SendIoTData failed. Status code: {response.StatusCode}");
                return string.Empty; 
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An error occurred during SendIoTData: {ex.Message}");
            return string.Empty; 
        }
    }
    public class SendIoTDataRequestDto
    {
        public Guid RoomId { get; set; }
        public double TemperatureC { get; set; }
        public double TemperatureF { get; set; }
        public double Humidity { get; set; }
        public DateTime TimeStamp { get; set; }
        public string OtherMetrics { get; set; }
    }
}
